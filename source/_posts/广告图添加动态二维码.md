----
title: 广告图添加动态二维码
date: 2019-11-18 15:05:34
tags:
    - java
    - work record
toc: true

----

*工作中一次业务逻辑的实现记录*。
## 业务说明
分销工具，需要统计分销者的pv和uv，因此要求每个分销员的广告素材图上，二维码链接均不相同，与该分销员绑定（这可以通过301重定向简单实现，比如用户23对产品102的二维码链接为`www.server.com/s/product102/user23`，后台会301重定向到实际页面，并记录每次访问）。
<!-- more -->
运营人员可以在管理后台为广告图添加二维码链接，并可以控制二维码宽度、border大小、二维码距离左上角的X、Y坐标。

编辑后台图示如下（图上的`375px`宽度只是因为一般设计稿的宽度都是375px，传到后端的是实际参数）：
![编辑后台图示](img/qrcode_palette.png)

传到后台服务的参数为：
```js
{
    	"imgUrl":"https://upload.17qms.com/Fhf4x6YJguVj4WKDjTo1pkUyqivJ",  // 素材图Url
    "linkUrl": "https://www.baidu.com", // 二维码链接，不过后台会为每个分销员生成对应的短链
    "qrCodeContainerWidth": 128,  // 二维码的宽度，包含border
    "qrCodeBorderWidth": 8,  // 二维码border的宽度
    "qrCodeBgColor": "#ffffff", // 前景色
    "qrCodeFgColor": "#ff0000", // 后景色
    "leftDistance": 236,
    "topDistance": 100,
    "naturalHeight": 452,  // 素材图的高度，单位像素
    "naturalWidth": 327 // 素材图的宽度，单位像素
}
```



## 任务拆解
刨除具体业务逻辑，如生成短链、任务触发等，只要两个步骤：
1. 生成链接对应的二维码图
2. 合并素材图与二维码图

### 生成链接的二维码
QR Code是一个二维码标准，具体原理就不深究了。
[zxing/zxing](https://github.com/zxing/zxing)是一个开源的1D/2D条形码处理库，支持多种格式，包括QR Code。

虽然`zxing`提供的`QRCodeWriter#eocnde`方法可以传`EncodeHintType.MARGIN`，不过实际测试的时候发现很难控制，并不能简单的当作border。 因此border的实现放在最后，即用`Graphics`类画图时用一个白色图层表示border：1. 先在画布上画上底图层（素材图）；2. 填充一个正方形来表示二维码的底层； 3.在填充的正方形上放二维码。
![结构说明](img/qrcode_desc.png)

将链接的Url转换成二维码`BUfferedImage`的方法如下：
```java
// 需要引入com.google.zxing
    /**
     * @param urlToDraw  要转换的链接url
     * @param qrCodeWith 二维码宽度
     * @param colorFg    前景色 前端传入#ffffffff~#00000000，需要处理下
     * @param colorBg    背景色
     * @return
     */
    public BufferedImage generateQrCode(String urlToDraw, int qrCodeWith , String colorFg, String colorBg) {

        QRCodeWriter writer = new QRCodeWriter();
        try {
            Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);
            hints.put(EncodeHintType.CHARACTER_SET, "UTF-8");
            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.Q);
            hints.put(EncodeHintType.MARGIN, 0);
            BitMatrix bitMatrix = writer.encode(urlToDraw, BarcodeFormat.QR_CODE, qrCodeWith, qrCodeWith, hints);
//            可以将结果写入到文件
//            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
//            File file = new File(fileName);
//            FileOutputStream fileOutputStream = new FileOutputStream(file);
//            MatrixToImageWriter.writeToStream(bitMatrix, "PNG", fileOutputStream);
            MatrixToImageConfig conf = new MatrixToImageConfig(Long.valueOf(colorFg.substring(1), 16).intValue(), Long.valueOf(colorBg.substring(1), 16).intValue());
            BufferedImage bufferedImage = MatrixToImageWriter.toBufferedImage(bitMatrix, conf);
            return bufferedImage;
        } catch (WriterException e) {
                // 异常处理 TODO:
        }
    }

```

`MatrixToImageWriter.writeToStream`可以将二维码数据写入到`OutputStream`，比如文件流中。
`MatrixToImageWriter.toBufferedImage(BitMatrix matrix, MatrixToImageConfig config)`方法会将二维码数据转换成`BufferedImage`返回，用于后续使用`java.awt`库来绘制合成图。该方法可以设置二维码的前景色和背景色。


### 使用Java的图形API拼合图片

合并图片的方法如下：
```java
    /**
     * 合并两张图片
     *
     * @param baseImageUrl 素材图的url
     * @param qrCodeImage  前一步生成的二维码BufferedImage
     * @param leftDistance
     * @param topDistance
     * @param border               宽度边框
     * @param outputFilePath       合并图片保存的位置
     * @param qrCodeContainerWidth 用来实现二维码的border
     * @param colorBg     边框的颜色，项目里使用二维码的背景色. 如#ffffffff，ARGB格式
     */
    public String mergeImage(String baseImageUrl, BufferedImage qrCodeImage, int leftDistance, int topDistance, String outputFilePath, int border, int qrCodeContainerWidth, String colorBg) {
        try {
            URL url = new URL(baseImageUrl);
            BufferedImage image = ImageIO.read(url);
            // 画布的长与宽
            int w = image.getWidth();
            int h = image.getHeight();
            BufferedImage combined = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);

            Graphics2D g = combined.createGraphics();
            // 画图，保存alpha通道
            g.drawImage(image, 0, 0, null);

            // 模拟背景色
            Color color = new Color(Integer.valueOf(colorBg.substring(3, 5), 16), Integer.valueOf(colorBg.substring(5, 7), 16), Integer.valueOf(colorBg.substring(7, 9), 16));
            g.setColor(color);
            g.fillRect(leftDistance, topDistance, qrCodeContainerWidth, qrCodeContainerWidth);
            g.drawImage(qrCodeImage, leftDistance + border, topDistance + border, null);

            // 保存图片
            ImageIO.write(combined, "PNG", new File(outputFilePath));
            return outputFilePath;
        } catch (IOException e) {
                // 异常处理 TODO:
        }
    }
```

方法使用`java.awt`库来绘制图片。 先创建一个和素材一样大的`BufferedImage combined`, 并调用`combined.createGraphics()`来得到一个`Graphics2D g`对象。  然后分别使用如下方法来“合并图片“：`Graphics2D#drawImage(Image img, int x, int y, ImageObserver observer)`来绘制素材图和二维码图、`Graphics2D#fillRect(int x, int y, int width, int height)`来绘制二维码的底层实现border。

合并后的图片在`outputFilePath`位置，后续可以上传到图片存储服务。
产生的图片如下：
![编辑后台图示](img/qrcode_drawed.png)

## `java.awt` API